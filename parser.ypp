%{
    #include <cstdio>
    #include <cstdlib>
    #include <iostream> 
    using namespace std; 
    #define YYDEBUG 1

  



    int yylex(void);
    void yyerror(const char *);
%}

/* Enables verbose error messages */
/* %error-verbose */
/** WRITE ME:
 *  - Put all your token definitions here
 *  - Put all your type definitions here
 *  - Put all your precedence/associativity rules here
 */



/* %union {
    std::list<Proc_ptr>* u_proc_list;
    Program* u_program;
    std::list<Decl_ptr>* u_decl_list;
    Proc* u_proc;
    std::list<Stat_ptr>* u_stat_list;
    Procedure_block* u_procedure_block;
    Nested_block* u_nested_block;
    std::list<SymName_ptr>* u_symname_list;
    Decl* u_decl;
    Stat* u_stat;
    std::list<Expr_ptr>* u_expr_list;
    Return_stat* u_return_stat;
    Type* u_type;
    Expr* u_expr;
    Lhs* u_lhs;
    SymName* u_symname;
    Primitive* u_primitive;
    StringPrimitive* u_stringprimitive;

    // a couple of hardcoded types
    char* u_base_charptr;
    int u_base_int;
} */

/* %type <u_expr> PrimaryExpr
%type <u_expr> Expression
%type <u_expr> AdditiveExpr
%type <u_expr> MultiplicativeExpr
%type <u_expr> UnaryExpr
%type <u_expr_list> ArgumentList
%type <u_lhs> Variable

%type <u_program> Program
%type <u_proc_list> ProcedureList
%type <u_proc> Procedure */


%token  IDENTIFIER
%token INT_LITERAL
%token CHAR_LITERAL



%token BOOLEAN CHAR INTEGER STRING INTPTR CHARPTR 
%token IF ELSE WHILE VAR PROCEDURE RETURN NULLTOKEN AND 
%token DIV EQUAL EQUALS GT GTE LT LTE MINUS NOT 
%token NOTEQUAL OR PLUS MUL AMP DEREFERENCE TRUE FALSE 
%token COMMA COLON UMINUS
%token LBRACE RBRACE SEMICOLON LPAREN RPAREN BAR 
%token LBRACKET RBRACKET STRING_LITERAL 

%left OR
%left AND
%left EQUALS NOTEQUAL
%left LT LTE GT GTE
%left PLUS MINUS
%left MUL DIV
%right NOT
%precedence DEREFERENCE
%precedence UMINUS



%%

Program : ProcedureList 
        ;

ProcedureList : Procedure 
              | Procedure ProcedureList 
              ;


Procedure : PROCEDURE IDENTIFIER LPAREN ParamList RPAREN RETURN Type LBRACE Body OptionalReturn RBRACE 
          ;

ParamList : 
          | Param
          | ParamList SEMICOLON Param
          ;

Param : IDList COLON Type
      ;

IDList : IDENTIFIER
       | IDENTIFIER COMMA IDList
       ;

Body : OptionalProcedures OptionalDeclarations OptionalStatements
     ;

OptionalProcedures :
                   | NestedProcedures
                   ;

NestedProcedures : Procedure
                 | Procedure NestedProcedures
                 ;
OptionalDeclarations : 
                     | Declarations
                     ;

OptionalStatements :
                   | Statements
                   ;

OptionalReturn : 
               | RETURN Expression SEMICOLON
               ;


Block : LBRACE OptionalDeclarations OptionalStatements RBRACE 
      ;


Declarations : VarDeclaration
             | VarDeclaration Declarations
             ;

VarDeclaration : VAR SingleVarDeclaration SEMICOLON
               | VAR MultiVarDeclaration SEMICOLON
               ;

SingleVarDeclaration : IDENTIFIER COLON STRING LBRACKET INT_LITERAL RBRACKET
                     | IDENTIFIER COLON Type 
                     ;

MultiVarDeclaration : IDList COLON Type 
                    | IDList COLON STRING LBRACKET INT_LITERAL RBRACKET
                    ;

Statements : Statement 
           | Statement Statements
           ;

Statement : IDENTIFIER EQUAL Expression SEMICOLON
          | IDENTIFIER EQUAL STRING_LITERAL SEMICOLON
          | IDENTIFIER LBRACKET Expression RBRACKET EQUAL Expression SEMICOLON 
          | IDENTIFIER LBRACKET Expression RBRACKET EQUAL STRING_LITERAL SEMICOLON
          | IF LPAREN Expression RPAREN Block
          | IF LPAREN Expression RPAREN Block ELSE Block
          | WHILE LPAREN Expression RPAREN Block
          | LBRACE Statements RBRACE
          | Block OptionalStatements
          | FunctionCall
          ;

FunctionCall : IDENTIFIER LPAREN ArgumentList RPAREN SEMICOLON

Expression : Expression OR Expression 
           | Expression AND Expression 
           | Expression EQUALS Expression 
           | Expression NOTEQUAL Expression 
           | Expression LT Expression 
           | Expression LTE Expression
           | Expression GT Expression 
           | Expression GTE Expression 
           | AdditiveExpr 
           ; 


AdditiveExpr : AdditiveExpr PLUS MultiplicativeExpr
             | AdditiveExpr MINUS MultiplicativeExpr
             | MultiplicativeExpr
             ;

MultiplicativeExpr : MultiplicativeExpr MUL UnaryExpr
                   | MultiplicativeExpr DIV UnaryExpr 
                   | UnaryExpr
                   ;

UnaryExpr : NOT UnaryExpr
          | MINUS UnaryExpr %prec UMINUS 
          | AMP Variable 
          | DEREFERENCE IDENTIFIER 
          | DEREFERENCE Expression 
          | DEREFERENCE IDENTIFIER LBRACKET INT_LITERAL RBRACKET 
          | BAR Expression BAR 
          | PrimaryExpr
          ;

Variable : IDENTIFIER 
         | IDENTIFIER LBRACKET Expression RBRACKET 
         ;

PrimaryExpr : IDENTIFIER 
            | INT_LITERAL 
            | LPAREN Expression RPAREN
            | IDENTIFIER LBRACKET Expression RBRACKET 
            | CHAR_LITERAL 
            | TRUE 
            | FALSE 
            | NULLTOKEN 
            ;

ArgumentList : 
             | ExpressionArg 
             | ExpressionArg COMMA ArgumentList
             ;

ExpressionArg : ExpressionArg OR ExpressionArg
              | ExpressionArg AND ExpressionArg
              | ExpressionArg EQUALS ExpressionArg
              | ExpressionArg NOTEQUAL ExpressionArg
              | ExpressionArg LT ExpressionArg
              | ExpressionArg LTE ExpressionArg
              | ExpressionArg GT ExpressionArg
              | ExpressionArg GTE ExpressionArg
              | AdditiveExprArg
              ;

AdditiveExprArg : AdditiveExprArg PLUS MultiplicativeExprArg
                | AdditiveExprArg MINUS MultiplicativeExprArg
                | MultiplicativeExprArg
                ;

MultiplicativeExprArg : MultiplicativeExprArg MUL UnaryExprArg
                      | MultiplicativeExprArg DIV UnaryExprArg
                      | UnaryExprArg
                      ;

UnaryExprArg : NOT UnaryExprArg
          | MINUS UnaryExprArg %prec UMINUS
          | AMP VariableArg    
          | DEREFERENCE IDENTIFIER 
          | DEREFERENCE ExpressionArg 
          | DEREFERENCE IDENTIFIER LBRACKET INT_LITERAL RBRACKET
          | BAR ExpressionArg BAR
          | PrimaryExprArg
          ;

VariableArg : IDENTIFIER
         | IDENTIFIER LBRACKET ExpressionArg RBRACKET
         ;

PrimaryExprArg : IDENTIFIER
            | INT_LITERAL
            | LPAREN ExpressionArg RPAREN
            | IDENTIFIER LBRACKET ExpressionArg RBRACKET 
            | CHAR_LITERAL 
            | TRUE 
            | FALSE 
            | NULLTOKEN 
            ;

Type : BOOLEAN
     | CHAR
     | INTEGER
     | INTPTR
     | CHARPTR
     ;



/** %token USELESS */

/* %% */
/* 
all : USELESS; */

%%

/** You shall not pass!
 *  You should not  have to do or edit anything past this.
 */

extern int yylineno;

void yyerror(const char *s)
{
    fprintf(stderr, "%s at line %d\n", s, yylineno);
    return;
}
